use zcash_mmr::{Entry, EntryLink, NodeData};

use crate::librustzcash_mmr_append;

const NODE_DATA: &str = r#"00000000000000000000000000000000000000000000000000000000000000000B000000140000006E000000780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101060000000000000000000000000000000000000000000000000000000000000000150000001E0000007800000082000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020207B2A5F285056BA19610B085B5DCBB277703E363E638E44FA6BEC3E5D3873AAF1B0B0000001E0000006E0000008200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001020D00000000000000000000000000000000000000000000000000000000000000001F00000028000000820000008C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030308000000000000000000000000000000000000000000000000000000000000000029000000320000008C000000960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000404096EA091D894B8BCC341AB5453EB7AB827B6127F99D76323CCEE65886DF847E1B21F0000003200000082000000960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000304118F23A7C5311184CDAA70748155CBBE6E31CAFBABDDDDC668885C9DC991472F6C0B000000320000006E0000009600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001041E0000000000000000000000000000000000000000000000000000000000000000330000003C00000096000000A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005050A00000000000000000000000000000000000000000000000000000000000000003D00000046000000A0000000AA00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006060BADC518E8DAC8319BAA616CB5985ACE30042777163C31171B3E6685ECEBCB36F8330000004600000096000000AA00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005061500000000000000000000000000000000000000000000000000000000000000004700000050000000AA000000B400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007070C0000000000000000000000000000000000000000000000000000000000000000510000005A000000B4000000BE00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080DC30447751A6E41E15321190BD31B91E5AB71C8E8192CD7D36C78446CDD3ACAE3470000005A000000AA000000BE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070819C595CB47E90DE10ED5660E41CFD481F0B4567E79C8202E9AF35AF3CFD2B97781330000005A00000096000000BE00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005082ED6145F949CDAD2D9C275631624ECD633B1553EDB9A92D555C7D6FB076319B4150B0000005A0000006E000000BE00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001084C00000000000000000000000000000000000000000000000000000000000000005B00000064000000BE000000C800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009090E"#;

fn preload_tree_append(vec: &Vec<NodeData>) -> (Vec<u32>, Vec<[u8; zcash_mmr::MAX_ENTRY_SIZE]>) {
    assert!(vec.len() > 0);

    // integer log2 of (vec.len()+1), -1
    let mut h = (32 - ((vec.len() + 1) as u32).leading_zeros() - 1) - 1;
    let mut peak_pos = (1 << (h + 1)) - 1;

    let mut peak_indices = Vec::new();
    let mut peaks = Vec::new();

    loop {
        if peak_pos > vec.len() {
            // left child, -2^h
            peak_pos = peak_pos - (1 << h);
            h = h - 1;
        }

        if peak_pos <= vec.len() {
            let mut peak: Entry = vec[peak_pos - 1].clone().into();
            if h != 0 {
                peak.update_siblings(
                    EntryLink::Stored((peak_pos - (1 << h) - 1) as u32),
                    EntryLink::Stored((peak_pos - 2) as u32),
                );
            }
            peak_indices.push((peak_pos - 1) as u32);
            let mut entry_buf = [0u8; zcash_mmr::MAX_ENTRY_SIZE];
            peak.write(&mut &mut entry_buf[..])
                .expect("Entry write failed");
            peaks.push(entry_buf);

            // right sibling
            peak_pos = peak_pos + (1 << (h + 1)) - 1;
        }

        if h == 0 {
            break;
        }
    }

    (peak_indices, peaks)
}

fn load_nodes() -> Vec<NodeData> {
    let mut res = Vec::new();

    let node_data: Vec<u8> = hex::decode(NODE_DATA).expect("Valid by declaration");

    let mut cursor = std::io::Cursor::new(&node_data[..]);
    while (cursor.position() as usize) < node_data.len() {
        let node_data =
            zcash_mmr::NodeData::read(0, &mut cursor).expect("Statically checked to be correct");
        res.push(node_data);
    }

    res
}

#[test]
fn append() {
    let nodes = load_nodes();
    let (indices, peaks) = preload_tree_append(&nodes);

    let mut rt_ret = [0u8; 32];

    let mut buf_ret = Vec::<[u8; zcash_mmr::MAX_NODE_DATA_SIZE]>::with_capacity(32);

    let mut new_node_data = [0u8; zcash_mmr::MAX_NODE_DATA_SIZE];
    let new_node = NodeData {
        consensus_branch_id: 0,
        subtree_commitment: [0u8; 32],
        start_time: 101,
        end_time: 110,
        start_target: 190,
        end_target: 200,
        start_sapling_root: [0u8; 32],
        end_sapling_root: [0u8; 32],
        subtree_total_work: Default::default(),
        start_height: 10,
        end_height: 10,
        shielded_tx: 13,
    };
    new_node
        .write(&mut &mut new_node_data[..])
        .expect("Failed to write node data");

    let result = librustzcash_mmr_append(
        0,
        nodes.len() as u32,
        indices.as_ptr(),
        peaks.as_ptr(),
        peaks.len(),
        &new_node_data,
        rt_ret.as_mut_ptr(),
        buf_ret.as_mut_ptr(),
    );

    unsafe {
        buf_ret.set_len(result as usize);
    }

    assert_eq!(result, 2);

    let new_node_1 =
        NodeData::from_bytes(0, &buf_ret[0][..]).expect("Failed to reconstruct return node #1");

    let new_node_2 =
        NodeData::from_bytes(0, &buf_ret[1][..]).expect("Failed to reconstruct return node #2");

    assert_eq!(new_node_1.start_height, 10);
    assert_eq!(new_node_1.end_height, 10);

    // this is combined new node (which is `new_node_1`) + the one which was there before (for block #9)
    assert_eq!(new_node_2.start_height, 9);
    assert_eq!(new_node_2.end_height, 10);
    assert_eq!(new_node_2.shielded_tx, 27);
}
