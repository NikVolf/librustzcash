use mmr::{Entry, EntryLink, NodeData};

use crate::librustzcash_mmr_append;

const NODE_DATA: &str = r#"00000000000000000000000000000000000000000000000000000000000000000A00000014000000640000006E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101050000000000000000000000000000000000000000000000000000000000000000150000001E0000006E00000078000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020204B0976627E4FA69D573C21F3CAE59248A9D2AC4BBBFFA411CDEC378A839E3898D0A0000001E000000640000007800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001020900000000000000000000000000000000000000000000000000000000000000001F00000028000000780000008200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003030600000000000000000000000000000000000000000000000000000000000000002900000032000000820000008C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000404077B9C6AA97861D690FFF511A7B4FBCCB45B17C82BBF2FFEA260D67B5B1BB18C6B1F00000032000000780000008C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003040D52905A4ACBE842783F5BFD3F57800B2D826BBF5964E25105F970685FD73253230A00000032000000640000008C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104160000000000000000000000000000000000000000000000000000000000000000330000003C0000008C0000009600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005050800000000000000000000000000000000000000000000000000000000000000003D0000004600000096000000A0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060609E2B23256A3DAEB8BB1ACE122369FE8374D75CA18B1A0492907D2FCA1261A2F8733000000460000008C000000A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005061100000000000000000000000000000000000000000000000000000000000000004700000050000000A0000000AA00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007070A0000000000000000000000000000000000000000000000000000000000000000510000005A000000AA000000B400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008080BF4773976FD9C31D67C928F063FC01DB3DD53CC12CE9E55EAF739FD772DDA7E4F470000005A000000A0000000B4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070815609E3E34CF514E8114E87F9FF6C71D09DB8A6F32050B0D4B1006D64314EA4B3D330000005A0000008C000000B40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000508263B801BDFBC9D65D2E0E75B87DCC23C8E61E22351CC5A6B22B99FB4ED34E6D8820A0000005A00000064000000B400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001083C00000000000000000000000000000000000000000000000000000000000000005B00000064000000B4000000BE00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009090C"#;

fn preload_tree_append(vec: &Vec<NodeData>) -> (Vec<u32>, Vec<[u8; mmr::MAX_ENTRY_SIZE]>) {
    assert!(vec.len() > 0);

    // integer log2 of (vec.len()+1), -1
    let mut h = (32 - ((vec.len() + 1) as u32).leading_zeros() - 1) - 1;
    let mut peak_pos = (1 << (h + 1)) - 1;

    let mut peak_indices = Vec::new();
    let mut peaks = Vec::new();

    loop {
        if peak_pos > vec.len() {
            // left child, -2^h
            peak_pos = peak_pos - (1 << h);
            h = h - 1;
        }

        if peak_pos <= vec.len() {
            let mut peak: Entry = vec[peak_pos - 1].clone().into();
            if h != 0 {
                peak.update_siblings(
                    EntryLink::Stored((peak_pos - (1 << h) - 1) as u32),
                    EntryLink::Stored((peak_pos - 2) as u32),
                );
            }
            peak_indices.push((peak_pos - 1) as u32);
            let mut entry_buf = [0u8; mmr::MAX_ENTRY_SIZE];
            peak.write(&mut &mut entry_buf[..])
                .expect("Entry write failed");
            peaks.push(entry_buf);

            // right sibling
            peak_pos = peak_pos + (1 << (h + 1)) - 1;
        }

        if h == 0 {
            break;
        }
    }

    (peak_indices, peaks)
}

fn load_nodes() -> Vec<NodeData> {
    let mut res = Vec::new();

    let node_data: Vec<u8> = hex::decode(NODE_DATA).expect("Valid by declaration");

    let mut cursor = std::io::Cursor::new(&node_data[..]);
    while (cursor.position() as usize) < node_data.len() {
        let node_data =
            mmr::NodeData::read(0, &mut cursor).expect("Statically checked to be correct");
        res.push(node_data);
    }

    res
}

#[test]
fn append() {
    let nodes = load_nodes();
    let (indices, peaks) = preload_tree_append(&nodes);

    let mut rt_ret = [0u8; 32];

    let mut buf_ret = Vec::<[u8; mmr::MAX_NODE_DATA_SIZE]>::with_capacity(32);

    let mut new_node_data = [0u8; mmr::MAX_NODE_DATA_SIZE];
    let new_node = NodeData {
        consensus_branch_id: 0,
        subtree_commitment: [0u8; 32],
        start_time: 101,
        end_time: 110,
        start_target: 190,
        end_target: 200,
        start_sapling_root: [0u8; 32],
        end_sapling_root: [0u8; 32],
        subtree_total_work: Default::default(),
        start_height: 10,
        end_height: 10,
        shielded_tx: 13,
    };
    new_node
        .write(&mut &mut new_node_data[..])
        .expect("Failed to write node data");

    let result = librustzcash_mmr_append(
        0,
        nodes.len() as u32,
        indices.as_ptr(),
        peaks.as_ptr(),
        peaks.len(),
        new_node_data.as_ptr(),
        rt_ret.as_mut_ptr(),
        buf_ret.as_mut_ptr(),
    );

    unsafe {
        buf_ret.set_len(result as usize);
    }

    assert_eq!(result, 2);

    let new_node_1 =
        NodeData::from_bytes(0, &buf_ret[0][..]).expect("Failed to reconstruct return node #1");

    let new_node_2 =
        NodeData::from_bytes(0, &buf_ret[1][..]).expect("Failed to reconstruct return node #2");

    assert_eq!(new_node_1.start_height, 10);
    assert_eq!(new_node_1.end_height, 10);

    // this is combined new node (which is `new_node_1`) + the one which was there before (for block #9)
    assert_eq!(new_node_2.start_height, 9);
    assert_eq!(new_node_2.end_height, 10);
    assert_eq!(new_node_2.shielded_tx, 25);
}
